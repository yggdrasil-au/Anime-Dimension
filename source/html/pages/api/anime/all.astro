---
/* API-driven All Anime page (SSG shell + CSR data)
 * Route usage: /experimental/anime-ssg-csr/all?name=love
 * Visually mirrors the offline All page but fetches data from the public API
 */

import Head from "@WWW-API-components/_Head.astro";
import Nav from "@WWW-API-components/_Nav.astro";
import Footer from "@WWW-API-components/_Footer.astro";
import UpperHeader from "@WWW-API-components/_UpperHeader.astro";
import HeroBanner from "@WWW-API-components/_HeroBanner.astro";
import ContentTopBanner from "@WWW-API-components/_ContentTopBanner.astro";
import LeftAdSidebar from "@WWW-API-components/_LeftAdSidebar.astro";
import InlineBanner from "@WWW-API-components/_InlineBanner.astro";
import RightSidebar from "@WWW-API-components/_RightSidebar.astro";

// Fully prerender at build time (shell only; data loads via API)
export const prerender = true;

// include root JS file dont use relative path
const MainJS = "/js/main.min.js";
---

<!doctype html>
<html lang="en" data-bs-theme="dark">
    <head>
        <Head title="Anime • All (API)" description="Browse and search anime via API. The page shell is pre-rendered; data loads dynamically." />
        <style>
            .MainSection { margin-top: 5rem; }
            .filters .form-control { max-width: 420px; }
            .results-meta { min-height: 1.5rem; }
        </style>
    </head>
    <body class="sidebar-collapsed">
        <div class="sky"></div>

        <header id="upper-header" class="upper-header p-3 d-table d-none">
            <UpperHeader />
        </header>

        <div id="app-wrapper">
            <nav id="main-nav" class="main-nav p-2">
                <Nav />
            </nav>
            <section>
                <section id="hero-banner" class="hero-banner sb sb-homepage fullbleed p-3 rounded">
                    <HeroBanner />
                </section>

                <div id="page-content-wrapper" style="height: 100%;" class="page-content-wrapper d-flex flex-column">
                    <section id="content-top-banner" class="content-top-banner p-3 rounded d-none">
                        <ContentTopBanner />
                    </section>

                    <div class="MainSection d-flex flex-column flex-md-row flex-grow-1">
                        <aside id="left-ad-sidebar" class="left-ad-sidebar-overlay rounded d-none">
                            <div class="left-ad-sidebar-content">
                                <button id="close-left-ad-sidebar" type="button" class="btn-close" aria-label="Close"></button>
                                <LeftAdSidebar />
                            </div>
                        </aside>

                        <main class="flex-grow-1 p-4">
                            <section id="inline-banner" class="inline-banner p-3 text-center rounded d-none">
                                <InlineBanner />
                            </section>

                            <section class="content-area">
                                <div class="container-xxl py-3">
                                    <header class="mb-3 d-flex align-items-center justify-content-between flex-wrap gap-2">
                                        <h1 class="h4 mb-0">All Anime (API)</h1>
                                        <div class="results-meta text-body-secondary small" id="resultsMeta" aria-live="polite"></div>
                                    </header>

                                    <!-- Search + controls -->
                                    <form id="searchForm" class="filters d-flex align-items-center gap-2 mb-3" method="get" action="">
                                        <div class="input-group" role="group" aria-label="API search">
                                            <span class="input-group-text" id="searchLabel"><i class="bi bi-search"></i></span>
                                            <input id="nameInput" name="name" type="search" class="form-control" placeholder="Search anime…" aria-labelledby="searchLabel" />
                                        </div>
                                        <button class="btn btn-primary" type="submit">Search</button>
                                    </form>
                                    <!-- Results grid (6-up like homepage) -->
                                    <div id="resultsGrid" class="row g-3 anim-row-fluid-6 row-cols-lg-6"></div>

                                    <!-- Pagination -->
                                    <nav id="pager" class="mt-3 d-flex flex-column align-items-center gap-2" aria-label="Results pages"></nav>
                                </div>
                            </section>
                        </main>

                        <aside id="right-sidebar" class="right-sidebar rounded d-none">
                            <RightSidebar />
                        </aside>
                    </div>
                </div>
            </section>

            <footer class="main-footer p-3 mt-auto d-none d-lg-block">
                <Footer />
            </footer>
        </div>

        <script is:inline>
            (function() {
                const byId = (id) => document.getElementById(id);
                const grid = byId('resultsGrid');
                const pager = byId('pager');
                const meta = byId('resultsMeta');
                const form = byId('searchForm');
                const input = byId('nameInput');

                const PAGE_SIZE = 42; // 6 x 7
                const MAX_FETCH = 420; // sanity cap to avoid huge payloads

                const getApiBase = () => {
                    const w = window;
                    const b = (w && w.AD_API_BASE) ? String(w.AD_API_BASE) : 'https://api.anime-dimension.com';
                    return b.replace(/\/$/, '');
                };

                const getParams = () => new URLSearchParams(location.search);
                const setParams = (params) => {
                    const url = new URL(location.href);
                    url.search = params.toString();
                    history.replaceState(null, '', url);
                };

                const norm = (s) => String(s || '').toLowerCase();
                const stripHtml = (html) => {
                    if (!html) return '';
                    const div = document.createElement('div');
                    div.innerHTML = String(html);
                    return (div.textContent || '').replace(/\s+/g, ' ').trim();
                };

                const toSlug = (u) => {
                    if (!u) return undefined;
                    try {
                        const m = /^\/?anime\/(.+)$/i.exec(String(u));
                        if (m) return m[1];
                        const url = new URL(String(u), 'https://anime-dimension.com');
                        const parts = url.pathname.split('/').filter(Boolean);
                        const i = parts.indexOf('anime');
                        return (i !== -1 && i + 1 < parts.length) ? parts[i + 1] : undefined;
                    } catch { return undefined; }
                };

                const normalizeItem = (raw) => {
                    const title = raw?.title || raw?.name || 'Untitled';
                    const slug = raw?.slug || toSlug(raw?.url) || toSlug(raw?.link) || title.toLowerCase().replace(/[^a-z0-9]+/g, '-');
                    const thumb = raw?.thumbnailUrl || raw?.imageUrl || raw?.image_url || raw?.image;
                    const summary = raw?.summary || stripHtml(raw?.tooltip || '');
                    const year = raw?.year;
                    const type = raw?.type;
                    const tooltip = typeof raw?.tooltip === 'string' ? raw.tooltip : '';
                    // Some APIs return tags array
                    const tags = Array.isArray(raw?.tags) ? raw.tags.filter(Boolean).map(String) : undefined;
                    return { slug, title, thumbnailUrl: thumb, summary, year, type, tooltip, tags };
                };

                const buildTooltipHtml = (it) => {
                    // Prefer server-provided tooltip HTML if available
                    if (it.tooltip && it.tooltip.trim() !== '') return it.tooltip;
                    const root = document.createElement('div');
                    const title = document.createElement('h5');
                    title.className = 'theme-font';
                    title.textContent = String(it.title || 'Untitled');
                    root.append(title);
                    const hasEntry = it.type || it.year;
                    if (hasEntry) {
                        const ul = document.createElement('ul');
                        ul.className = 'entryBar';
                        if (it.type) { const li = document.createElement('li'); li.className = 'type'; li.textContent = String(it.type); ul.append(li); }
                        if (it.year) { const li = document.createElement('li'); li.className = 'iconYear'; li.textContent = String(it.year); ul.append(li); }
                        root.append(ul);
                    }
                    if (it.summary) { const p = document.createElement('p'); p.textContent = String(it.summary); root.append(p); }
                    if (Array.isArray(it.tags) && it.tags.length) {
                        const tagsDiv = document.createElement('div');
                        tagsDiv.className = 'tags';
                        const h4 = document.createElement('h4'); h4.textContent = 'Tags'; tagsDiv.append(h4);
                        const ul = document.createElement('ul');
                        for (const t of it.tags) { const li = document.createElement('li'); li.textContent = String(t); ul.append(li); }
                        tagsDiv.append(ul); root.append(tagsDiv);
                    }
                    return root.innerHTML;
                };

                const renderGrid = (list) => {
                    grid.innerHTML = '';
                    for (const it of list) {
                        const col = document.createElement('div');
                        const card = document.createElement('div');
                        card.className = 'card h-100 anim-card';
                        const img = document.createElement('img');
                        img.className = 'card-img-top';
                        if (it.thumbnailUrl) img.src = it.thumbnailUrl;
                        img.alt = it.title || '';
                        img.loading = 'lazy';
                        img.decoding = 'async';
                        const body = document.createElement('div');
                        body.className = 'card-body p-2';
                        const title = document.createElement('h6');
                        title.className = 'card-title anim-card-title mb-1';
                        title.textContent = it.title || '';
                        const link = document.createElement('a');
                        link.href = it.slug ? `/anime/ssg-csr/${encodeURIComponent(it.slug)}` : '#';
                        link.className = 'stretched-link';
                        link.setAttribute('aria-label', it.title || 'View');
                        try {
                            const tooltipHtml = buildTooltipHtml(it);
                            if (tooltipHtml && tooltipHtml.trim() !== '') {
                                card.setAttribute('data-bs-toggle', 'tooltip');
                                card.setAttribute('data-bs-placement', 'auto');
                                card.setAttribute('data-bs-custom-class', 'anim-tooltip');
                                card.setAttribute('data-tooltip-html', tooltipHtml);
                            }
                        } catch { /* ignore */ }
                        body.append(title);
                        card.append(img, body, link);
                        col.append(card);
                        grid.append(col);
                    }
                };

                const renderPager = (total, page, onPage) => {
                    pager.innerHTML = '';
                    const pages = Math.max(1, Math.ceil(total / PAGE_SIZE));
                    if (pages <= 1) return;

                    const mkBtn = (label, p, { disabled = false, active = false, ariaLabel } = {}) => {
                        const btn = document.createElement('button');
                        btn.type = 'button';
                        btn.className = 'btn btn-sm ' + (active ? 'btn-primary' : 'btn-outline-secondary');
                        btn.textContent = label;
                        if (ariaLabel) btn.setAttribute('aria-label', ariaLabel);
                        if (active) btn.setAttribute('aria-current', 'page');
                        btn.disabled = disabled;
                        if (!disabled && !active) btn.addEventListener('click', () => onPage(p));
                        return btn;
                    };

                    const mkEllipsis = () => {
                        const btn = document.createElement('button');
                        btn.type = 'button';
                        btn.className = 'btn btn-sm btn-outline-secondary disabled';
                        btn.textContent = '…';
                        btn.setAttribute('tabindex', '-1');
                        btn.setAttribute('aria-hidden', 'true');
                        btn.disabled = true;
                        return btn;
                    };

                    const isCompact = (window.innerWidth || 0) < 430;

                    const group = document.createElement('div');
                    group.className = 'btn-group';
                    group.setAttribute('role', 'group');
                    group.setAttribute('aria-label', 'Pagination');

                    group.append(mkBtn('Prev', Math.max(1, page - 1), {
                        disabled: page <= 1,
                        ariaLabel: 'Previous page',
                    }));

                    if (!isCompact) {
                        const around = 2;
                        const edge = 1;
                        const show = new Set();
                        const pagesCount = Math.max(1, Math.ceil(total / PAGE_SIZE));
                        for (let i = 1; i <= edge; i++) show.add(i);
                        for (let i = pagesCount - edge + 1; i <= pagesCount; i++) if (i >= 1) show.add(i);
                        for (let i = page - around; i <= page + around; i++) if (i >= 1 && i <= pagesCount) show.add(i);
                        const list = Array.from(show).sort((a, b) => a - b);
                        let prevNum = 0;
                        for (const num of list) {
                            if (prevNum && num - prevNum > 1) group.append(mkEllipsis());
                            group.append(mkBtn(String(num), num, { active: num === page }));
                            prevNum = num;
                        }
                    }

                    group.append(mkBtn('Next', page + 1, {
                        disabled: page >= Math.max(1, Math.ceil(total / PAGE_SIZE)),
                        ariaLabel: 'Next page',
                    }));

                    pager.append(group);

                    // Page jump
                    const jumpForm = document.createElement('form');
                    jumpForm.className = 'd-flex align-items-center gap-2 pager-jump';
                    jumpForm.setAttribute('aria-label', 'Go to page');
                    const label = document.createElement('label');
                    label.className = 'visually-hidden';
                    label.textContent = 'Go to page';
                    const inputId = 'pagerJumpInput';
                    label.setAttribute('for', inputId);
                    const inputNum = document.createElement('input');
                    inputNum.type = 'number';
                    inputNum.id = inputId;
                    inputNum.className = 'form-control form-control-sm';
                    inputNum.placeholder = 'Page #';
                    inputNum.min = '1';
                    inputNum.max = String(Math.max(1, Math.ceil(total / PAGE_SIZE)));
                    inputNum.inputMode = 'numeric';
                    inputNum.style.width = '6rem';
                    const goBtn = document.createElement('button');
                    goBtn.type = 'submit';
                    goBtn.className = 'btn btn-sm btn-primary';
                    goBtn.textContent = 'Go';
                    jumpForm.append(label, inputNum, goBtn);
                    jumpForm.addEventListener('submit', (ev) => {
                        ev.preventDefault();
                        const n = Number.parseInt(inputNum.value, 10);
                        if (Number.isFinite(n)) {
                            const target = Math.max(1, n);
                            onPage(target);
                        }
                    });
                    pager.append(jumpForm);
                };

                // Cache last fetched list to avoid re-downloading on small interactions
                let cached = { count: 0, items: [] };

                const fetchPool = async (needCount) => {
                    const needed = Math.min(Math.max(PAGE_SIZE, needCount), MAX_FETCH);
                    if (cached.count >= needed && cached.items.length >= needed) return cached.items.slice();
                    try {
                        const body = new URLSearchParams();
                        body.set('totalRequested', String(needed));
                        body.set('type', 'anime');
                        const res = await fetch(`${getApiBase()}/api/anime/all`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8' },
                            body: body.toString(),
                            credentials: 'include',
                        });
                        if (!res.ok) throw new Error(`HTTP ${res.status}`);
                        const json = await res.json();
                        const list = Array.isArray(json?.list) ? json.list : (Array.isArray(json) ? json : []);
                        const items = list.map(normalizeItem).filter(it => it.slug && it.title);
                        cached = { count: needed, items };
                        return items.slice();
                    } catch (e) {
                        console.error('[AD] anime/all failed', e);
                        return [];
                    }
                };

                const update = async () => {
                    const params = getParams();
                    const q = params.get('name') || '';
                    const pageParam = Math.max(1, Number.parseInt(params.get('page') || '1', 10) || 1);
                    if (input) input.value = q;

                    // Ensure we have at least enough items for the requested page
                    const poolRaw = await fetchPool(pageParam * PAGE_SIZE);
                    // Filter locally by query
                    const pool = poolRaw.filter((it) => {
                        if (!q) return true;
                        const nq = norm(q);
                        if (norm(it.title).includes(nq)) return true;
                        if (norm(it.slug).includes(nq)) return true;
                        if (it.summary && norm(it.summary).includes(nq)) return true;
                        if (Array.isArray(it.tags) && it.tags.some(t => norm(t).includes(nq))) return true;
                        return false;
                    });

                    const total = pool.length;
                    const pages = Math.max(1, Math.ceil(total / PAGE_SIZE));
                    const page = Math.min(pages, pageParam);
                    if (page !== pageParam) {
                        const p = getParams();
                        p.set('page', String(page));
                        setParams(p);
                    }

                    const start = (page - 1) * PAGE_SIZE;
                    const pageItems = pool.slice(start, start + PAGE_SIZE);

                    renderGrid(pageItems);
                    renderPager(total, page, (nextPage) => {
                        const p = getParams();
                        p.set('page', String(nextPage));
                        setParams(p);
                        void update();
                    });

                    if (meta) {
                        meta.textContent = q ? `${total} result${total === 1 ? '' : 's'} for "${q}"` : `${total} result${total === 1 ? '' : 's'}`;
                    }
                };

                form?.addEventListener('submit', (ev) => {
                    ev.preventDefault();
                    const q = input ? input.value.trim() : '';
                    const p = getParams();
                    if (q) p.set('name', q); else p.delete('name');
                    p.delete('page');
                    setParams(p);
                    void update();
                });

                // Initial render
                void update();

                // Re-render on resize so pager adapts under 430px
                let resizeTimer = 0;
                window.addEventListener('resize', () => {
                    clearTimeout(resizeTimer);
                    resizeTimer = window.setTimeout(() => { void update(); }, 150);
                });
            })();
        </script>

        <!-- Main bundle (theme + utilities). Already used globally. -->
        <script is:inline src={MainJS}></script>
        <!-- Shared tooltip runtime (UMD) -->
        <script is:inline src="/js/ui/tooltips.min.js"></script>

    </body>
</html>

